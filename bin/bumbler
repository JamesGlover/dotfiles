#!/usr/bin/env ruby
# generated by rubinjam v0.5.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "bumbler" => "module Bumbler\n  autoload :Bundler,  'bumbler/bundler'\n  autoload :Hooks,    'bumbler/hooks'\n  autoload :Progress, 'bumbler/progress'\n  autoload :Stats,    'bumbler/stats'\n  autoload :VERSION,  'bumbler/version'\nend\n",
    "bumbler/go" => "require 'bumbler'\n\n# Do nothing unless we're in a bundle\nbegin\n  require 'bundler'\n  # This raises if there isn't a gemfile in our root\n  Bundler.default_gemfile\n  \n  # Kick it off\n  Bumbler::Hooks.hook_require!\n  Bumbler::Hooks.watch_require!\n    \n  Bumbler::Bundler.start!\n  Bumbler::Progress.start!\n  \nrescue\n  # Welp, if we fail, we fail.\nend\n",
    "bumbler/track_initializers" => "Rails::Engine.class_eval do\n  def load(initializer)\n    initializer = initializer.sub(Rails.root.to_s, \".\")\n    Bumbler::Hooks.benchmark(initializer) { super }.last\n  end\nend\n\nRails::Initializable::Initializer.class_eval do\n  alias_method :run_without_bumbler, :run\n  def run(*args)\n    name = (@name.is_a?(Symbol) ? @name.inspect : @name)\n    Bumbler::Hooks.benchmark(name) { run_without_bumbler(*args) }.last\n  end\nend\n",
    "bumbler/version" => "module Bumbler\n  VERSION = '0.3.1'\nend\n",
    "bumbler/hooks" => "module Bumbler\n  module Hooks\n    @slow_threshold = 100.0\n    @previous_gems = {}\n    @slow_requires = {}\n\n    # Everything's a class method (we're a singleton)\n    class << self\n      def slow_threshold=(time)\n        @slow_threshold = time\n      end\n\n      def slow_requires\n        @slow_requires\n      end\n\n      # Inject our custom handling of require into the Kernel.\n      def hook_require!\n        @hooking_require = true\n\n        # There are two independent require methods.  Joy!\n        ::Kernel.module_eval do\n          class << self\n            orig_public_require = Kernel.public_method(:require)\n            define_method(:require) do |path, *args|\n              ::Bumbler::Hooks.handle_require(path) do\n                orig_public_require.call(path, *args)\n              end\n            end\n          end\n\n          orig_instance_require = self.instance_method(:require)\n          define_method(:require) do |path, *args|\n            ::Bumbler::Hooks.handle_require(path) do\n              orig_instance_require.bind(self).call(path, *args)\n            end\n          end\n        end\n\n        @hooking_require = nil\n      end\n\n      # Even better: Other gems hook require as well.  The instance method one at least.\n      def watch_require!\n        ::Kernel.module_eval do\n          # It isn't previously defined in Kernel.  This could be a bit dangerous, though.\n          def self.method_added(method_name, *args)\n            if method_name == :require && !::Bumbler::Hooks.hooking_require?\n              # Fix those hooks.\n              ::Bumbler::Hooks.hook_require!\n            end\n          end\n        end\n      end\n\n      def hooking_require?\n        @hooking_require\n      end\n\n      # Actually do something about a require here.\n      def handle_require(path, &block)\n        # break out early if we're already handling this\n        return yield if path == @previous_require\n        @previous_require = path\n\n        # Shortcut unless we're tracking the gem\n        gem_name = Bumbler::Bundler.gem_for_require(path)\n        return yield unless gem_name\n\n        # Track load starts\n        Bumbler::Bundler.require_started(path) unless @previous_gems[gem_name]\n        @previous_gems[gem_name] = true\n\n        time, result = benchmark(path, &block)\n\n        Bumbler::Bundler.require_finished(path, time) if result\n\n        result\n      end\n\n      def benchmark(key)\n        start = Time.now.to_f\n        result = yield\n        time = (Time.now.to_f - start) * 1000 # ms\n        @slow_requires[key] = time if time > @slow_threshold\n        return time, result\n      end\n    end\n  end\nend\n",
    "bumbler/stats" => "module Bumbler\n  module Stats\n    class << self\n      def tracked_items\n        Bumbler::Progress.registry.each do |type, items|\n          puts \"Stats for \#{type} items:\"\n          \n          items.to_a.sort_by! {|n,d| d[:time].to_f}.each do |name, info|\n            if info[:time]\n              puts '  %s  %s' % [('%.2f' % info[:time]).rjust(8), name]\n            else\n              puts \"  pending:  \#{name}\"\n            end\n          end\n        end\n        \n        self\n      end\n      \n      def all_slow_items\n        puts \"Slow requires:\"\n        Bumbler::Hooks.slow_requires.to_a.sort_by! {|n,t| t}.each do |name, time|\n          puts '  %s  %s' % [('%.2f' % time).rjust(8), name]\n        end\n        \n        self\n      end\n    end\n  end\nend\n",
    "bumbler/bundler" => "module Bumbler\n  module Bundler\n    class << self\n      # Returns which gem a require maps to, or nil.\n      def gem_for_require(path)\n        self.read_bundler_environment if @require_map.nil?\n        \n        return @require_map[path]\n      end\n      \n      def require_started(path)\n        gem_name = self.gem_for_require(path)\n        return unless gem_name\n        \n        Bumbler::Progress.item_started(:bundler, gem_name)\n      end\n      \n      def require_finished(path, load_time)\n        self.read_bundler_environment if @gem_state.nil?\n        \n        # Tick it off for the gem.\n        gem_name = self.gem_for_require(path)\n        return unless gem_name\n        \n        @gem_state[gem_name][path] = true\n        \n        if @gem_state[gem_name].values.all?\n          Bumbler::Progress.item_finished(:bundler, gem_name, load_time)\n        end\n      end\n      \n      def start!\n        self.read_bundler_environment\n      end\n      \n      def read_bundler_environment\n        @require_map = {}\n        @gem_state = {}\n        \n        ::Bundler.environment.current_dependencies.each do |spec|\n          @gem_state[spec.name] = {}\n          \n          Array(spec.autorequire || spec.name).each do |path|\n            @require_map[path] = spec.name\n            @gem_state[spec.name][path] = false\n          end\n          \n          Bumbler::Progress.register_item(:bundler, spec.name)\n        end\n      end\n    end\n  end\nend\n",
    "bumbler/progress" => "module Bumbler\n  module Progress\n    @item_count   = 0\n    @loaded_items = 0\n\n    # registry[item_type][item_name] = {:time => 123.45}\n    @registry = Hash.new { |h,k| h[k] = {} }\n\n    class << self\n      def registry\n        @registry\n      end\n\n      def register_item(type, name)\n        # Build a blank key for the item\n        unless @registry[type][name]\n          @item_count  += 1\n        end\n\n        @registry[type][name] = {}\n      end\n\n      def item_started(type, name)\n        @curr_item = {:type => type, :name => name}\n\n        self.render_progress\n      end\n\n      def item_finished(type, name, time)\n        @registry[type][name] = {:time => time}\n\n        @loaded_items  += 1\n\n        @prev_item = {:type => type, :name => name, :time => time}\n        @curr_item = nil if @curr_item && @curr_item[:name] == @prev_item[:name] && @curr_item[:type] == @prev_item[:type]\n\n        self.render_progress\n      end\n\n      def start!\n        # No-op for now.\n      end\n\n      def tty_width\n        `tput cols`.to_i || 80\n      end\n\n      def bar(width)\n        inner_size = width - 2\n\n        fill_size = [((@loaded_items.to_f / @item_count.to_f) * inner_size).to_i, inner_size].min\n        fill  = '#' * fill_size\n        empty = ' ' * (inner_size - fill_size)\n\n        return \"[\#{fill}\#{empty}]\"\n      end\n\n      def render_progress\n        # Do nothing if we don't have any items to load\n        return if @item_count == 0\n\n        # Output components:\n        #   [#######################################]\n        #   (##/##) <current>...   <prev> (####.##ms)\n        #\n        # Skip the current if there isn't enough room\n        count   = '(%s/%d) ' % [@loaded_items.to_s.rjust(@item_count.to_s.size), @item_count]\n        current = @curr_item ? \"\#{@curr_item[:name]}... \" : ''\n        prev    = @prev_item ? '%s (%sms)' % [@prev_item[:name], ('%.2f' % @prev_item[:time]).rjust(7)] : ''\n\n        if $stdout.tty?\n          width = self.tty_width\n\n          print \"\\r\\e[A\\r\\e[A\" if @outputted_once\n          @outputted_once = true\n\n          # Align the bottom row\n          space_for_current = width - (count.length + prev.length)\n\n          # Render the progress\n          puts self.bar(width)\n\n          if space_for_current >= current.length\n            puts count + current + prev.rjust(width - count.length - current.length)\n          else\n            puts count + prev.rjust(width - count.length)\n          end\n        elsif @curr_item\n          puts '%s %s' % [count, @curr_item[:name]]\n        end\n      end\n    end\n  end\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
add_load_path = lambda do
  path = File.join(File.dirname(__FILE__), '..', 'lib')
  $LOAD_PATH << path unless $LOAD_PATH.include? path
end

add_load_path.call # in case we execute via ./bin

require 'optparse'
require 'bumbler'

options = {}
OptionParser.new do |parser|
  parser.banner = <<BANNER
Bumbler shows how long loading your bundle components take.

Usage:
    bumbler

Options:
BANNER
  parser.on("-t", "--threshold MILISECONDS", Integer, "Threshold in ms to be listed as slow") { |t| options[:threshold] = t }
  parser.on("--initializers", "Show load time of initializers") { options[:initializers] = true }
  parser.on("-h", "--help", "Show this.") { puts parser; exit }
  parser.on('-v', '--version', 'Show Version'){ puts Bumbler::VERSION; exit}
end.parse!

Bumbler::Hooks.slow_threshold = options[:threshold] if options[:threshold]

if options[:initializers]
  require './config/application'
  add_load_path.call # bundler kicks us out
  require 'bumbler/track_initializers'
  require './config/environment'
else
  require 'bumbler/go'
  require './config/environment'
  add_load_path.call # bundler kicks us out
end

Bumbler::Stats.all_slow_items
