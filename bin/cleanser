#!/usr/bin/env ruby
# generated by rubinjam v0.5.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "cleanser" => "module Cleanser\n  class << self\n    def cli(argv)\n      options = parse_options(argv)\n      find_polluter(argv, options) ? 0 : 1\n    end\n\n    def find_polluter(files, options={})\n      failing = files.pop\n      expand_folders(files, failing)\n\n      if !files.include?(failing)\n        abort \"Files have to include the failing file\"\n      elsif files.size < 2\n        abort \"Files have to be more than 2\"\n      elsif !success?([failing], options)\n        abort \"\#{failing} fails when run on it's own\"\n      elsif success?(files, options)\n        abort \"tests pass locally\"\n      else\n        loop do\n          a = remove_from(files, files.size / 2, :not => failing)\n          b = files - (a - [failing])\n          status, files = find_polluter_set([a, b], failing, options)\n          if status == :finished\n            puts \"Fails when \#{files.join(\", \")} are run together\"\n            return true\n          elsif status == :continue\n            next\n          else\n            abort \"unable to isolate failure to 2 files\"\n          end\n        end\n      end\n    end\n\n    private\n\n    def parse_options(argv)\n      require 'optparse'\n      options = {}\n      OptionParser.new do |opts|\n        opts.banner = <<-BANNER.gsub(/^ {10}/, \"\")\n          Find polluting test by bisecting your tests.\n\n\n          Usage:\n              cleanser a.rb failing.rb b.rb c.rb failing.rb\n              cleanser folder failing.rb\n\n          Options:\n        BANNER\n        opts.on(\"-r\", \"--rspec\", \"RSpec\") { options[:rspec] = true }\n        opts.on(\"-s\", \"--seed=SEED\", \"Use seed to run tests\") { |seed| options[:seed] = seed }\n        opts.on(\"-h\", \"--help\", \"Show this.\") { puts opts; exit }\n        opts.on(\"-v\", \"--version\", \"Show Version\") do\n          require 'cleanser/version' unless defined?(Cleanser::VERSION)\n          puts Cleanser::VERSION; exit\n        end\n      end.parse!(argv)\n      options\n    end\n\n    def expand_folders(files, failing)\n      files.map! do |f|\n        if File.file?(f)\n          f\n        elsif f =~ /\".+\"/\n          f.split(/, ?/).map { |f| f.tr('\"', '') }\n        else\n          files_from_folder(f, pattern(failing))\n        end\n      end.flatten!\n    end\n\n    def files_from_folder(folder, pattern)\n      nested = \"{,/*/**}\" # follow one symlink and direct children\n      Dir[File.join(folder, nested, pattern)].map{|f|f.gsub(\"//\", \"/\")}\n    end\n\n    def pattern(test)\n      base = File.basename(test)\n      if base =~ /^test_/\n        \"\#{$&}*\"\n      elsif base =~ /(_test|_spec)\\.rb/\n        \"*\#{$1}.rb\"\n      else\n        \"*\"\n      end\n    end\n\n    def find_polluter_set(sets, failing, options)\n      sets.each do |set|\n        next if set == [failing]\n        if !success?(set, options)\n          if set.size == 2\n            return [:finished, set]\n          else\n            return [:continue, set]\n          end\n        end\n      end\n      return [:failure, []]\n    end\n\n    def remove_from(set, x, options)\n      set.dup.delete_if { |f| f != options[:not] && (x -= 1) >= 0 }\n    end\n\n    def success?(files, options)\n      addition = if seed = options[:seed]\n        \"\#{\" --\" unless options[:rspec]} --seed \#{seed}\"\n      end\n\n      command = if options[:rspec]\n        \"bundle exec rspec \#{files.join(\" \")}\#{addition}\"\n      else\n        require = files.map do |f|\n          f = \"./\#{f}\" unless f.start_with?(\"/\")\n          \"-r \#{f.sub(/\\.rb$/, \"\")}\"\n        end.join(\" \")\n        \"bundle exec ruby \#{require} -e ''\#{addition}\"\n      end\n      puts \"Running: \#{command}\"\n      status = system(command)\n      puts \"Status: \#{status ? \"Success\" : \"Failure\"}\"\n      status\n    end\n  end\nend\n",
    "cleanser/version" => "module Cleanser\n  VERSION = \"0.2.1\"\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
root = File.expand_path("../..", __FILE__)
$LOAD_PATH << "#{root}/lib" if File.exist?("#{root}/Gemfile")

require "cleanser"
exit Cleanser.cli(ARGV)
