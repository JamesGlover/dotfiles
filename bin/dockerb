#!/usr/bin/env ruby
# generated by rubinjam v0.5.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "dockerb/version" => "module Dockerb\n  VERSION = \"0.2.2\"\nend\n",
    "dockerb" => "require 'erb'\n\nmodule Dockerb\n  class << self\n    def compile\n      return (yield if block_given?) unless File.exist?(\"Dockerfile.erb\")\n      begin\n        File.write(\"Dockerfile\", Context.compile(File.read(\"Dockerfile.erb\")))\n        yield if block_given?\n      ensure\n        File.unlink(\"Dockerfile\") if File.exist?(\"Dockerfile\") && block_given?\n      end\n    end\n  end\n\n  class Context\n    class << self\n      def compile(code)\n        ERB.new(code).result(binding)\n      end\n\n      def bundle\n        <<-EOF.gsub(/^          /, \"\")\n          ADD Gemfile /app/\n          ADD Gemfile.lock /app/\n          ADD vendor/cache /app/vendor/cache\n          RUN (bundle install --quiet --local --jobs 4 || bundle check) && \#{delete_gem_junk}\n        EOF\n      end\n\n      def install_gem(name, options=nil)\n        options = \" \" << options if options\n        version = File.read(\"Gemfile.lock\")[/^    \#{name} \\((.+)\\)/, 1] || raise(\"Gem \#{name} not found in Gemfile.lock\")\n        \"RUN gem install -v \#{version} \#{name}\#{options} && \#{delete_gem_junk}\"\n      end\n\n      def delete_gem_junk\n        \"\#{delete_tests} && \#{delete_build_files}\"\n      end\n\n      private\n\n      def delete_tests\n        %{find \#{gem_home}/ -maxdepth 2 -name \"test\" -o -name \"spec\" | xargs rm -r}\n      end\n\n      # deleting all of ext makes nokogiri + Nokogumbo install fail\n      def delete_build_files\n        %{find \#{gem_home}/*/ext/ -maxdepth 1 -mindepth 1 -type d | xargs -I% make -C % clean}\n      end\n\n      def gem_home\n        \"/usr/local/lib/ruby/gems/*/gems\"\n      end\n    end\n  end\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
# enable local usage from cloned repo
root = File.expand_path("../..", __FILE__)
$LOAD_PATH << "#{root}/lib" if File.exist?("#{root}/Gemfile")

require 'optparse'

OptionParser.new do |opts|
  opts.banner = <<-BANNER.gsub(/^    /, "")
    Dockerfile.erb - use ruby in your dynamic Dockerfile

    Options:
  BANNER
  opts.on("-h", "--help", "Show this.") { puts opts; exit }
  opts.on("-v", "--version", "Show Version"){ require 'dockerb/version'; puts Dockerb::VERSION; exit}
end.parse!(ARGV)

require "dockerb"
Dockerb.compile
