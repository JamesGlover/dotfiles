#!/usr/bin/env ruby
# generated by rubinjam v0.0.0 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "pru/version" => "module Pru\n  VERSION = \"0.1.8\"\nend\n",
    "pru/core_ext/array" => "class Array\n  # http://madeofcode.com/posts/74-ruby-core-extension-array-sum\n  def sum(method = nil, &block)\n    if block_given?\n      raise ArgumentError, \"You cannot pass a block and a method!\" if method\n      inject(0) { |sum, i| sum + yield(i) }\n    elsif method\n      inject(0) { |sum, i| sum + i.send(method) }\n    else\n      inject(0) { |sum, i| sum + i }\n    end\n  end unless method_defined?(:sum)\n\n  def mean(method = nil, &block)\n    sum(method, &block) / size.to_f\n  end unless method_defined?(:mean)\n\n  def grouped\n    group_by { |x| x }\n  end unless method_defined?(:grouped)\n\n  def counted\n    grouped.sort_by{|d, f| -1 * f.size }.map{|d, f| \"\#{d} : \#{f.size}\" }\n  end unless method_defined?(:counted)\n\n  def group_by\n    hash = {}\n    each { |x| hash[yield(x)] = x }\n    hash\n  end unless method_defined?(:group_by)\nend\n",
    "pru/core_ext/symbol" => "class Symbol\n  def to_proc\n    proc { |obj, *args| obj.send(self, *args) }\n  end unless method_defined?(:to_proc)\nend\n",
    "pru" => "require 'pru/core_ext/array'\nrequire 'pru/core_ext/symbol'\n\nmodule Pru\n  class << self\n    def map(io, code)\n      String.class_eval <<-RUBY, __FILE__, __LINE__ + 1\n        def _pru(i)\n          \#{code}\n        end\n      RUBY\n\n      i = 0\n      io.each_line do |line|\n        i += 1\n        line.chomp!\n        result = line._pru(i) or next\n\n        case result\n        when true then yield line\n        when Regexp then yield line if line =~ result\n        else yield result\n        end\n      end\n    end\n\n    def reduce(array, code)\n      Array.class_eval <<-RUBY, __FILE__, __LINE__ + 1\n        def _pru\n          \#{code}\n        end\n      RUBY\n      array._pru\n    end\n  end\nend\n"
  }
end

def require(file)
  if code = Rubinjam::LIBRARIES[file]
    return if code == :loaded
    eval(code, TOPLEVEL_BINDING, "rubinjam/#{file}")
    Rubinjam::LIBRARIES[file] = :loaded
  else
    super
  end
end
#!/usr/bin/env ruby
require 'optparse'

$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')
require 'pru'

usage = nil
options = {}

OptionParser.new do |opts|
  opts.banner = <<BANNER
Pipeable Ruby

Use ruby in your pipes, forget about grep / sed / awk / wc ...

Map works on each line as String
Reduce works on all lines as Array (optional or via -r)

Usage:
    something | pru 'map'
    something | pru 'map' 'reduce'
    something | pru '' 'reduce'
    something | pru --reduce 'reduce'

Options:
BANNER
  opts.on("-r", "--reduce CODE","reduce via CODE") {|code| options[:reduce] = code }
  opts.separator ''
  opts.on('-I', '--libdir DIR', 'Add DIR to load path') { |dir| $LOAD_PATH << dir }
  opts.on('--require LIB', 'Require LIB (also comma-separated)') { |lib|
    begin
      require 'rubygems'
    rescue LoadError
    end
    lib.split(',').each{|l| require l }
  }
  opts.on('-i', '--inplace-edit FILE', 'Edit FILE inplace') { |file| options[:file] = file }
  opts.separator ''
  opts.on("-h", "--help","Show this.") { puts opts; exit }
  opts.on('-v', '--version','Show Version'){ require 'pru/version'; puts Pru::VERSION; exit}
  usage = opts
end.parse!

if ARGV.empty? and options.empty? # no arguments -> show usage
  puts usage
  exit
end

abort "Too many arguments, see --help" if ARGV.size > 2

map, reduce = ARGV
reduce ||= options[:reduce]
map = 'true' if not map or map.empty?

if options[:file]
  output_lines = []
  input = File.read(options[:file])
  newline = input[/\r\n|\r|\n/]
else
  input = $stdin
end

collector = lambda{|line|
  output_lines ? output_lines << line : puts(line)
}

if reduce
  results = []
  Pru.map(input, map){|out| results << out }
  collector.call Pru.reduce(results, reduce)
else
  Pru.map(input, map){|out| collector.call out }
end

if options[:file]
  File.open(options[:file], 'w'){|f| f.write output_lines.join(newline) }
end
