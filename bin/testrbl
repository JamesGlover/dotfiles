#!/usr/bin/env ruby
# generated by rubinjam v0.5.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "testrbl" => "require 'testrbl/version'\n\nmodule Testrbl\n  PATTERNS = [\n    /^(\\s+)(should|test|it)\\s+['\"](.*)['\"]\\s+do\\s*(?:#.*)?$/,\n    /^(\\s+)(context|describe)\\s+['\"]?(.*?)['\"]?\\s+do\\s*(?:#.*)?$/,\n    /^(\\s+)def\\s+(test_)([a-z_\\d]+)\\s*(?:#.*)?$/\n  ]\n\n  OPTION_WITH_ARGUMENT = [\"-I\", \"-r\", \"-n\", \"--name\", \"-e\", \"--exclude\", \"-s\", \"--seed\"]\n  INTERPOLATION = /\\\\\\#\\\\\\{.*?\\\\\\}/\n\n  class << self\n    def run_from_cli(argv)\n      files, options = partition_argv(argv)\n      files.concat(changed_files) if options.delete(\"--changed\")\n      files = files.map { |f| localize(f) }\n      load_options, options = partition_options(options)\n\n      if files.size == 1 and files.first =~ /^(\\S+):(\\d+)$/\n        file = $1\n        line = $2\n        run(ruby + load_options + line_pattern_option(file, line) + options)\n      else\n        if files.size == 1 and File.file?(files.first)\n          run(ruby + load_options + files + options)\n        elsif options.none? { |arg| arg =~ /^-n/ }\n          seed = if seed = options.index(\"--seed\")\n            [\"--\"] + options.slice!(seed, 2)\n          else\n            []\n          end\n          files = files.map { |f| File.directory?(f) ? all_test_files_in(f) : f }.flatten\n          run(ruby + load_options + files.map { |f| \"-r\#{f}\" } + options + [\"-e\", \"\"] + seed)\n        else # pass though\n          # no bundle exec: projects with mini and unit-test do not run well via bundle exec testrb\n          run [\"testrb\"] + argv\n        end\n      end\n    end\n\n    # overwritten by maxitest to just return line\n    def line_pattern_option(file, line)\n      [file, \"-n\", \"/\#{pattern_from_file(File.readlines(file), line)}/\"]\n    end\n\n    # usable via external tools like zeus\n    def pattern_from_file(lines, line)\n      possible_lines = lines[0..(line.to_i-1)].reverse\n\n      found = possible_lines.map { |line| test_pattern_from_line(line) || block_start_from_line(line) }.compact\n\n      # pattern and the groups it is nested under (like describe - describe - it)\n      last_spaces = \" \" * 100\n      patterns = found.select do |spaces, name|\n        last_spaces = spaces if spaces.size < last_spaces.size\n      end.map(&:last).compact\n\n      return filter_duplicate_final(patterns).reverse.join(\".*\") if found.size > 0\n\n      raise \"no test found before line \#{line}\"\n    end\n\n    # only keep 1 pattern that stops matching via $\n    def filter_duplicate_final(patterns)\n      found_final = 0\n      patterns.reject { |p| p.end_with?(\"$\") and (found_final += 1) > 1 }\n    end\n\n    private\n\n    def all_test_files_in(folder)\n      Dir[File.join(folder, \"{**/,}*_{test,spec}.rb\")].uniq\n    end\n\n    def partition_options(options)\n      next_is_before = false\n      options.partition do |option|\n        if next_is_before\n          next_is_before = false\n          true\n        else\n          if option =~ /^-(r|I)/\n            next_is_before = (option.size == 2)\n            true\n          else\n            false\n          end\n        end\n      end\n    end\n\n    # fix 1.9 not being able to load local files\n    def localize(file)\n      file =~ /^[-a-z\\d_]/ ? \"./\#{file}\" : file\n    end\n\n    def partition_argv(argv)\n      next_is_option = false\n      argv.partition do |arg|\n        if next_is_option\n          next_is_option = false\n        else\n          if arg =~ /^-.$/ or  arg =~ /^--/ # single letter option followed by argument like -I test or long options like --verbose\n            next_is_option = true if OPTION_WITH_ARGUMENT.include?(arg)\n            false\n          elsif arg =~ /^-/ # multi letter option like -Itest\n            false\n          else\n            true\n          end\n        end\n      end\n    end\n\n    def changed_files\n      changed_files = sh(\"git status -s\").split(\"\\n\").map { |l| l.strip.split(/\\s+/, 2)[1] }\n\n      if changed_files.empty?\n        # user wants to test last commit and not current diff\n        changed_files = sh(\"git show --name-only\").split(\"\\n\\n\").last.split(\"\\n\")\n      end\n\n      # we only want test files that were added or changed (not deleted)\n      changed_files.select { |f| f =~ /_(test|spec)\\.rb$/ && File.exist?(f) }\n    end\n\n    def sh(command)\n      result = `\#{command}`\n      raise \"Failed: \#{command} -> \#{result}\" unless $?.success?\n      result\n    end\n\n    def ruby\n      if File.file?(\"Gemfile\")\n        [\"ruby\", \"-rbundler/setup\"] # faster then bundle exec ruby\n      else\n        [\"ruby\"]\n      end\n    end\n\n    def run(command)\n      puts command.join(\" \")\n      STDOUT.flush # if exec fails horribly we at least see some output\n      Kernel.exec *command\n    end\n\n    def block_start_from_line(line)\n      if line =~ /^(\\s*).* do( \\|.*\\|)?$/\n        [$1, nil]\n      end\n    end\n\n    def test_pattern_from_line(line)\n      PATTERNS.each do |r|\n        next unless line =~ r\n        whitespace, method, test_name = $1, $2, $3\n        return [whitespace, test_pattern_from_match(method, test_name)]\n      end\n      nil\n    end\n\n    def test_pattern_from_match(method, test_name)\n      regex = Regexp.escape(test_name).gsub(\"\\\\ \",\" \").gsub(INTERPOLATION, \".*\")\n\n      regex = if method == \"test\"\n        # test \"xxx -_ yyy\"\n        # test-unit:     \"test: xxx -_ yyy\"\n        # activesupport: \"test_xxx_-__yyy\"\n        \"^test(: |_)\#{regex.gsub(\" \", \".\")}$\"\n      elsif method == \"describe\" || (method == \"context\" && !via_shoulda?)\n        \"\#{regex}(::)?\"\n      elsif method == \"should\" && via_shoulda?\n        optional_test_name = \"(?:\\(.*\\))?\"\n        \"\#{method} \#{regex}\\. \#{optional_test_name}$\"\n      elsif [\"it\", \"should\"].include?(method) # minitest aliases for shoulda\n        \"#test_\\\\d+_\#{regex}$\"\n      else\n        regex\n      end\n\n      regex.gsub(\"'\", \".\")\n    end\n\n    def via_shoulda?\n      return @via_shoulda if defined?(@via_shoulda)\n      @via_shoulda = !File.exist?(\"Gemfile.lock\") || File.read(\"Gemfile.lock\").include?(\" shoulda-context \")\n    end\n  end\nend\n",
    "testrbl/version" => "module Testrbl\n  VERSION = '0.8.0'\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
$LOAD_PATH.unshift File.expand_path("../../lib", __FILE__)
require "testrbl"
Testrbl.run_from_cli(ARGV)
