#!/usr/bin/env ruby
# generated by rubinjam v0.0.0 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "testrbl/version" => "module Testrbl\n  VERSION = '0.5.0'\nend\n",
    "testrbl" => "require 'testrbl/version'\n\nmodule Testrbl\n  PATTERNS = [\n    /^(\\s+)(should|test|it)\\s+['\"](.*)['\"]\\s+do\\s*(?:#.*)?$/,\n    /^(\\s+)(context|describe)\\s+['\"]?(.*?)['\"]?\\s+do\\s*(?:#.*)?$/,\n    /^(\\s+)def\\s+(test_)([a-z_\\d]+)\\s*(?:#.*)?$/\n  ]\n\n  OPTION_WITH_ARGUMENT = [\"-I\", \"-r\", \"-n\", \"-e\"]\n  INTERPOLATION = /\\\\\\#\\\\\\{.*?\\\\\\}/\n\n  def self.run_from_cli(argv)\n    files, options = partition_argv(argv)\n    files.concat(changed_files) if options.delete(\"--changed\")\n    files = files.map { |f| localize(f) }\n    load_options, options = partition_options(options)\n\n    if files.size == 1 and files.first =~ /^(\\S+):(\\d+)$/\n      file = $1\n      line = $2\n      run(ruby + load_options + line_pattern_option(file, line) + options)\n    else\n      if files.size == 1 and File.file?(files.first)\n        run(ruby + load_options + files + options)\n      elsif options.none? { |arg| arg =~ /^-n/ }\n        files = files.map { |f| File.directory?(f) ? all_test_files_in(f) : f }.flatten\n        run(ruby + load_options + files.map { |f| \"-r\#{f}\" } + options + [\"-e\", \"\"])\n      else # pass though\n        # no bundle exec: projects with mini and unit-test do not run well via bundle exec testrb\n        run [\"testrb\"] + argv\n      end\n    end\n  end\n\n  # overwritten by maxitest to just return line\n  def self.line_pattern_option(file, line)\n    [file, \"-n\", \"/\#{pattern_from_file(File.readlines(file), line)}/\"]\n  end\n\n  # usable via external tools like zeus\n  def self.pattern_from_file(lines, line)\n    possible_lines = lines[0..(line.to_i-1)].reverse\n\n    found = possible_lines.map { |line| test_pattern_from_line(line) || block_start_from_line(line) }.compact\n\n    # pattern and the groups it is nested under (like describe - describe - it)\n    last_spaces = \" \" * 100\n    patterns = found.select do |spaces, name|\n      last_spaces = spaces if spaces.size < last_spaces.size\n    end.map(&:last).compact\n\n    return filter_duplicate_final(patterns).reverse.join(\".*\") if found.size > 0\n\n    raise \"no test found before line \#{line}\"\n  end\n\n  # only keep 1 pattern that stops matching via $\n  def self.filter_duplicate_final(patterns)\n    found_final = 0\n    patterns.reject { |p| p.end_with?(\"$\") and (found_final += 1) > 1 }\n  end\n\n  private\n\n  def self.all_test_files_in(folder)\n    Dir[File.join(folder, \"{**/,}*_{test,spec}.rb\")].uniq\n  end\n\n  def self.partition_options(options)\n    next_is_before = false\n    options.partition do |option|\n      if next_is_before\n        next_is_before = false\n        true\n      else\n        if option =~ /^-(r|I)/\n          next_is_before = (option.size == 2)\n          true\n        else\n          false\n        end\n      end\n    end\n  end\n\n  # fix 1.9 not being able to load local files\n  def self.localize(file)\n    file =~ /^[-a-z\\d_]/ ? \"./\#{file}\" : file\n  end\n\n  def self.partition_argv(argv)\n    next_is_option = false\n    argv.partition do |arg|\n      if next_is_option\n        next_is_option = false\n      else\n        if arg =~ /^-.$/ or  arg =~ /^--/ # single letter option followed by argument like -I test or long options like --verbose\n          next_is_option = true if OPTION_WITH_ARGUMENT.include?(arg)\n          false\n        elsif arg =~ /^-/ # multi letter option like -Itest\n          false\n        else\n          true\n        end\n      end\n    end\n  end\n\n  def self.changed_files\n    changed_files = `git status -s`.split(\"\\n\").map { |l| l.strip.split(/\\s+/, 2)[1] }\n    raise \"Failed: \#{changed_files}\" unless $?.success?\n    changed_files.select { |f| f =~ /_(test|spec)\\.rb$/ && File.exist?(f) }\n  end\n\n  def self.ruby\n    if File.file?(\"Gemfile\")\n      [\"ruby\", \"-rbundler/setup\"] # faster then bundle exec ruby\n    else\n      [\"ruby\"]\n    end\n  end\n\n  def self.run(command)\n    puts command.join(\" \")\n    STDOUT.flush # if exec fails horribly we at least see some output\n    Kernel.exec *command\n  end\n\n  def self.block_start_from_line(line)\n    if line =~ /^(\\s*).* do( \\|.*\\|)?$/\n      [$1, nil]\n    end\n  end\n\n  def self.test_pattern_from_line(line)\n    PATTERNS.each do |r|\n      next unless line =~ r\n      whitespace, method, test_name = $1, $2, $3\n      return [whitespace, test_pattern_from_match(method, test_name)]\n    end\n    nil\n  end\n\n  def self.test_pattern_from_match(method, test_name)\n    regex = Regexp.escape(test_name).gsub(\"\\\\ \",\" \").gsub(INTERPOLATION, \".*\")\n\n    regex = if method == \"test\"\n      # test \"xxx -_ yyy\"\n      # test-unit:     \"test: xxx -_ yyy\"\n      # activesupport: \"test_xxx_-__yyy\"\n      \"^test(: |_)\#{regex.gsub(\" \", \".\")}$\"\n    elsif method == \"describe\" || (method == \"context\" && !via_shoulda?)\n      \"\#{test_name}(::)?\"\n    elsif method == \"should\" && via_shoulda?\n      optional_test_name = \"(?:\\(.*\\))?\"\n      \"\#{method} \#{regex}\\. \#{optional_test_name}$\"\n    elsif [\"it\", \"should\"].include?(method) # minitest aliases for shoulda\n      \"#test_\\\\d+_\#{test_name}$\"\n    else\n      regex\n    end\n\n    regex.gsub(\"'\", \".\")\n  end\n\n  def self.via_shoulda?\n    return @via_shoulda if defined?(@via_shoulda)\n    @via_shoulda = !File.exist?(\"Gemfile.lock\") || File.read(\"Gemfile.lock\").include?(\" shoulda-context \")\n  end\nend\n"
  }
end

def require(file)
  if code = Rubinjam::LIBRARIES[file]
    return if code == :loaded
    eval(code, TOPLEVEL_BINDING, "rubinjam/#{file}")
    Rubinjam::LIBRARIES[file] = :loaded
  else
    super
  end
end
#!/usr/bin/env ruby
$LOAD_PATH.unshift File.expand_path("../../lib", __FILE__)
require "testrbl"
Testrbl.run_from_cli(ARGV)
