#!/usr/bin/env ruby
# generated by rubinjam v0.5.1 -- https://github.com/grosser/rubinjam
module Rubinjam
  LIBRARIES = {
    "wwtd" => "require \"wwtd/version\"\nrequire \"optparse\"\nrequire \"yaml\"\nrequire \"shellwords\"\nrequire \"tempfile\"\nrequire \"tmpdir\"\nrequire \"wwtd/ruby\"\nrequire \"wwtd/run\"\nrequire \"wwtd/cli\"\n\nmodule WWTD\n  CONFIG = \".travis.yml\"\n  DEFAULT_GEMFILE = \"Gemfile\"\n  COMBINATORS = [\"rvm\", \"gemfile\", \"env\"]\n  UNDERSTOOD = COMBINATORS + [\"matrix\", \"script\", \"bundler_args\"]\n\n  class << self\n    def read_travis_yml(options={})\n      config = (File.exist?(CONFIG) ? YAML.load_file(CONFIG) : {})\n      config.delete(\"source_key\") # we don't need that we already have the source\n      ignored = (config.keys - UNDERSTOOD - Array(options[:use])) + Array(options[:ignore])\n\n      calculate_local_ruby_matrix = (\n        ignored.include?(\"rvm\") &&\n        Array(config[\"rvm\"]).include?(RUBY_VERSION) &&\n        config[\"matrix\"]\n      )\n\n      ignored.each { |i| config.delete(i) unless i == \"rvm\" && calculate_local_ruby_matrix }\n      matrix = matrix(config)\n\n      if calculate_local_ruby_matrix\n        matrix.delete_if { |m| m[\"rvm\"] != RUBY_VERSION }\n        matrix.each { |m| m.delete(\"rvm\") }\n      end\n\n      [matrix, ignored]\n    end\n\n    def run(matrix, options, &block)\n      with_clean_dot_bundle do\n        with_clean_env do\n          Dir.mktmpdir do |lock|\n            in_multiple_threads(matrix.each_with_index, options[:parallel]) do |config, i|\n              # set env as parallel_tests does to reuse existing infrastructure\n              env = {}\n              env[\"TEST_ENV_NUMBER\"] = (i == 0 ? \"\" : (i + 1).to_s) if options[:parallel]\n              if options[:only_bundle]\n                config['script'] = 'test \"only bundle\"'\n              end\n              Run.new(config, env, lock).execute(&block)\n            end\n          end\n        end\n      end\n    end\n\n    # internal api\n    # needs the export to work on ruby 1.9 / linux\n    def escaped_env(env, options={})\n      return \"\" if env.empty?\n\n      if options[:rerun] && gemfile = env[\"BUNDLE_GEMFILE\"]\n        env[\"BUNDLE_GEMFILE\"] = gemfile.sub(\"\#{Dir.pwd}/\", \"\")\n      end\n\n      env = env.map { |k,v| \"\#{k}=\#{Shellwords.escape(v)}\" }\n      if options[:rerun]\n        env.join(\" \") + \" \"\n      else\n        env.map { |e| \"export \#{e}\" }.join(\" && \") + \" && \"\n      end\n    end\n\n    private\n\n    # internal api\n    def sh(env, cmd=nil)\n      cmd, env = env, {} unless cmd\n      env = escaped_env(env)\n      puts cmd\n      system(\"\#{env}\#{cmd}\")\n    end\n\n    def with_clean_dot_bundle\n      had_old = File.exist?(\".bundle\")\n      Dir.mktmpdir do |dir|\n        begin\n          sh \"mv .bundle \#{dir}\" if had_old\n          yield\n        ensure\n          sh \"rm -rf .bundle\"\n          sh \"mv \#{dir}/.bundle .\" if had_old\n        end\n      end\n    end\n\n    def matrix(config)\n      if config[\"env\"] && config[\"env\"].is_a?(Hash)\n        global = if config[\"env\"][\"global\"]\n          \" \" + config[\"env\"][\"global\"].join(\" \")\n        else\n          \"\"\n        end\n        if config[\"env\"][\"matrix\"]\n          config[\"env\"] = config[\"env\"][\"matrix\"].map { |v| v + global }\n        else\n          config[\"env\"] = global.strip\n        end\n      end\n\n      matrix = [{}]\n      COMBINATORS.each do |multiplier|\n        next unless values = config[multiplier]\n        matrix = Array(values).map { |value| matrix.map { |c| c.merge(multiplier => value) } }.flatten\n      end\n\n      if matrix_config = config.delete(\"matrix\")\n        if exclude = matrix_config[\"exclude\"]\n          matrix -= exclude\n        end\n        if include = matrix_config[\"include\"]\n          if matrix == [{}]\n            matrix = include\n          else\n            matrix += include\n          end\n        end\n      end\n      matrix.map! { |c| config.merge(c) }\n    end\n\n    def with_clean_env(&block)\n      if defined?(Bundler)\n        Bundler.with_clean_env(&block)\n      else\n        yield\n      end\n    end\n\n    def in_multiple_threads(data, count)\n      data = data.to_a.dup\n      threads = [count || 1, data.size].min\n      results = []\n      (0...threads).to_a.map do\n        Thread.new do\n          while slice = data.shift\n            results << yield(slice)\n          end\n        end\n      end.each(&:join)\n      results\n    end\n  end\nend\n",
    "wwtd/cli" => "module WWTD\n  module CLI\n    INFO_MAX_CHARACTERS = 30\n    STATE_COLOR_MAP = {:start => :yellow, :success => :green}\n    ASCII_COLORS = {:red => 31, :green => 32, :yellow => 33}\n\n    class << self\n      def run(argv=[])\n        options = parse_options(argv)\n\n        # Read travis.yml\n        matrix, ignored = ::WWTD.read_travis_yml(options)\n        puts \"Ignoring: \#{ignored.sort.join(\", \")}\" if ignored.any?\n\n        # Execute tests\n        results = protect_against_nested_runs do\n          ::WWTD.run(matrix, options) do |state, config|\n            puts info_line(state, config, matrix)\n          end\n        end\n\n        print_summary(matrix, results)\n        print_rerun(results)\n\n        results.all? { |state, config| state == :success } ? 0 : 1\n      end\n\n      private\n\n      def print_rerun(results)\n        failed = results.select { |s, c| s == :failure }\n        if failed.any?\n          puts \"\\nFailed:\"\n          failed.each do |state, config|\n            runner = WWTD::Run.new(config.merge(:rerun => true), {}, nil)\n            env, cmd = runner.env_and_command_for_section(\"script\")\n            env = WWTD.escaped_env(env, :rerun => true)\n            puts colorize(:red, env + cmd)\n          end\n        end\n      end\n\n      def print_summary(matrix, results)\n        if results.size > 1\n          puts \"\\nResults:\"\n          results.each { |state, config| puts info_line(state, config, matrix) }\n        end\n      end\n\n      def protect_against_nested_runs\n        env = (defined?(Bundler) ? Bundler::ORIGINAL_ENV : ENV)\n\n        raise \"Already running WWTD\" if env[\"INSIDE_WWTD\"]\n        env['INSIDE_WWTD'] = \"1\"\n        yield\n      ensure\n        env['INSIDE_WWTD'] = nil\n      end\n\n\n      def parse_options(argv)\n        options = {\n          :ignore => [],\n          :use => [],\n        }\n        OptionParser.new do |opts|\n          opts.banner = <<-BANNER.gsub(/^ {10}/, \"\")\n            WWTD: Travis simulator - faster + no more waiting for build emails\n\n            Usage:\n                wwtd\n\n            Options:\n          BANNER\n          opts.on(\"-l\", \"--local\", \"Ignore rvm options / only run on current ruby\") { options[:ignore] << \"rvm\" }\n          opts.on(\"-i\", \"--ignore FIELDS\", String, \"Ignore selected travis fields like rvm/gemfile/matrix/...\") { |fields| options[:ignore] += fields.split(\",\") }\n          opts.on(\"-u\", \"--use FIELDS\", String, \"Use dangerous travis fields like before_install/install/before_script/...\") { |fields| options[:use] += fields.split(\",\") }\n          opts.on(\"-p\", \"--parallel [COUNT]\", Integer, \"Run in parallel\") { |c| options[:parallel] = c || 4 }\n          opts.on(\"-o\", \"--only-bundle\", \"Only bundle, do not run anything\") { options[:only_bundle] = true }\n          opts.on(\"-h\", \"--help\", \"Show this.\") { puts opts; exit }\n          opts.on(\"-v\", \"--version\", \"Show Version\"){ puts WWTD::VERSION; exit}\n        end.parse!(argv)\n        options\n      end\n\n      def info_line(state, config, matrix)\n        config_info = config_info(matrix, config)\n        color = STATE_COLOR_MAP[state] || :red\n\n        \"\#{colorize(color, state.to_s.upcase)} \#{config_info}\"\n      end\n\n      # human readable config without options that are the same in all configs\n      # {\"a\" => 1, \"b\" => 2} + {\"a\" => 2, \"b\" => 2} => {\"a\" => 1} + {\"a\" => 2}\n      def config_info(matrix, config)\n        config = config.select { |k,v| matrix.map { |c| c[k] }.uniq.size > 1 }.sort # find non-unique values aka interesting\n        maximum_value_lengths = Hash[config.map { |k,_| [k, matrix.map { |h| h[k].to_s.size }.max ] }] # find maximum value length for each key so we can align\n        config.map do |k, v|\n          value = truncate(v, INFO_MAX_CHARACTERS).ljust([INFO_MAX_CHARACTERS, maximum_value_lengths[k]].min)\n          \"\#{k}: \#{value}\"\n        end.join(\" \") # truncate values that are too long\n      end\n\n      def truncate(value, number)\n        value = value.to_s # accidental numbers like 'rvm: 2.0'\n        if value.size > number\n          \"\#{value[0...27]}...\"\n        else\n          value\n        end\n      end\n\n      def colorize(color, string)\n        if $stdout.tty?\n          \"\\e[\#{ASCII_COLORS[color]}m\#{string}\\e[0m\"\n        else\n          string\n        end\n      end\n    end\n  end\nend\n",
    "wwtd/ruby" => "module WWTD\n  module Ruby\n    class << self\n      def available?(version)\n        !version || switch_statement(version)\n      end\n\n      # - rvm: \"rvm xxx do\"\n      # - chruby: \"chruby-exec xxx --\"\n      # - others: env hash\n      # - unknown: nil\n      def switch_statement(version, options={})\n        return unless version\n        version = normalize_ruby_version(version)\n        if rvm_executable\n          command = \"rvm-exec \#{version} \"\n          command if cache_command(\"\#{command} ruby -v\")\n        elsif chruby_executable\n          command = \"chruby-exec \#{version} -- \"\n          command if cache_command(\"\#{command} ruby -v\")\n        elsif options[:rerun]\n          if rbenv_executable\n            # cannot call different ruby from inside ruby, but ok for copy-paste\n            \"RBENV_VERSION=\#{version} \"\n          else\n            # don't print giant path hack :/\n            \"USE-RUBY-\#{version}\"\n          end\n        else\n          if ruby_root = ENV[\"RUBY_ROOT\"] # chruby or RUBY_ROOT set\n            switch_via_env(File.dirname(ruby_root), version)\n          elsif rbenv_executable\n            rubies_root = cache_command(\"rbenv root\") + \"/versions\"\n            switch_via_env(rubies_root, version)\n          end\n        end\n      end\n\n      private\n\n      def switch_via_env(rubies_root, version)\n        base = extract_jruby_rbenv_options!(version)\n        if ruby_root = ruby_root(rubies_root, version)\n          gem_home = Dir[\"\#{ruby_root}/lib/ruby/gems/*\"].first\n          base.merge(\n            \"PATH\" => \"\#{ruby_root}/bin:\#{ENV[\"PATH\"]}\",\n            \"GEM_HOME\" => gem_home,\n            \"GEM_PATH\" => gem_home\n          )\n        end\n      end\n\n      def rvm_executable\n        cache_command(\"which rvm\")\n      end\n\n      def rbenv_executable\n        cache_command(\"which rbenv\")\n      end\n\n      def chruby_executable\n        !ENV[\"PATH\"].include?(\"/rbenv/\") && cache_command(\"which chruby-exec\")\n      end\n\n      def cache_command(command)\n        cache(command) do\n          if result = capture(command)\n            result.strip\n          end\n        end\n      end\n\n      def ruby_root(root, version)\n        Dir.glob(\"\#{root}/*\").detect do |p|\n          File.basename(p).sub(/^ruby-/,\"\").start_with?(version)\n        end\n      end\n\n      def cache(key)\n        @cache ||= {}\n        if @cache.key?(key)\n          @cache[key]\n        else\n          @cache[key] = yield\n        end\n      end\n\n      # set ruby-opts for jruby flavors\n      def extract_jruby_rbenv_options!(version)\n        if version.sub!(\"-d19\", \"\")\n          { \"JRUBY_OPTS\" => \"--1.9\" }\n        elsif version.sub!(\"-d18\", \"\")\n          { \"JRUBY_OPTS\" => \"--1.8\" }\n        else\n          {}\n        end\n      end\n\n      def capture(command)\n        result = `\#{command}`\n        $?.success? ? result : nil\n      end\n\n      # Taken from https://github.com/travis-ci/travis-build/blob/master/lib/travis/build/script/rvm.rb\n      def normalize_ruby_version(rvm)\n        rvm.to_s.\n          gsub(/-(\\d{2})mode$/, '-d\\1').\n          gsub(/^rbx$/, 'rbx-weekly-d18').\n          gsub(/^rbx-d(\\d{2})$/, 'rbx-weekly-d\\1')\n      end\n    end\n  end\nend\n",
    "wwtd/tasks" => "require \"wwtd\"\n\nrun_wwtd = lambda { |args| exit 1 unless WWTD::CLI.run(args) == 0 }\ndesc \"test on all combinations defined in .travis.yml\"\ntask :wwtd do\n  run_wwtd.call([])\nend\n\nnamespace :wwtd do\n  desc \"test on all combinations defined in .travis.yml in parallel\"\n  task :parallel do\n    run_wwtd.call([\"--parallel\"])\n  end\n\n  desc \"test on all combinations defined in .travis.yml on current ruby\"\n  task :local do\n    run_wwtd.call([\"--ignore\", \"rvm\"])\n  end\n\n  desc \"bundle for all combinations\"\n  task :bundle do\n    run_wwtd.call([\"--only-bundle\", \"--ignore\", \"rvm\"])\n  end\nend\n",
    "wwtd/run" => "module WWTD\n  class Run\n\n    SCRIPT_SECTIONS = [\"before_install\", \"install\", \"before_script\", \"script\", \"after_script\"]\n\n    def initialize(config, env, lock)\n      @config, @env, @lock = config, env, lock\n      add_env_from_config\n      @switch = build_switch_statement\n    end\n\n    def execute\n      state = if Ruby.available?(config[\"rvm\"])\n        yield(:start, config)\n        success? ? :success : :failure\n      else\n        :missing_ruby_version\n      end\n\n      yield(state, config)\n\n      [state, config]\n    end\n\n    # internal api\n    def env_and_command_for_section(key)\n      if command = config[key]\n        command = [command] unless Array === command\n        command = command.map { |cmd| \"\#{switch}\#{cmd}\" }.join(\" && \")\n\n        [env, command]\n      elsif key == \"script\"\n        command = (wants_bundle? ? \"\#{switch}bundle exec rake\" : \"\#{switch}rake\")\n        [env, command]\n      end\n    end\n\n    private\n\n    attr_reader :config, :env, :lock, :switch\n\n    def success?\n      if wants_bundle?\n        flock File.join(lock, (config[\"rvm\"] || \"rvm\").to_s) do\n          default_bundler_args = \"--deployment --path \#{Dir.pwd}/vendor/bundle\" if committed?(\"\#{gemfile || DEFAULT_GEMFILE}.lock\")\n          bundle_command = \"\#{switch}bundle install \#{config[\"bundler_args\"] || default_bundler_args}\"\n          return false unless sh(env, \"\#{bundle_command.strip} --quiet\")\n        end\n      end\n\n      SCRIPT_SECTIONS.each do |section|\n        if env_and_command = env_and_command_for_section(section)\n          return unless sh(*env_and_command)\n        end\n      end\n\n      true\n    end\n\n    def wants_bundle?\n      gemfile || File.exist?(DEFAULT_GEMFILE)\n    end\n\n    def gemfile\n      config[\"gemfile\"]\n    end\n\n    def build_switch_statement\n      switch_ruby = Ruby.switch_statement(config[\"rvm\"], :rerun => config[:rerun])\n      if switch_ruby.is_a?(Hash)\n        env.merge!(switch_ruby)\n        switch_ruby = nil\n      end\n      switch_ruby\n    end\n\n    def add_env_from_config\n      Shellwords.split(config[\"env\"] || \"\").each do |part|\n        name, value = part.split(\"=\", 2)\n        env[name] = value\n      end\n      env[\"BUNDLE_GEMFILE\"] = File.expand_path(gemfile) if gemfile\n    end\n\n    def committed?(file)\n      @committed_files ||= (File.exist?(\".git\") && `git ls-files`.split(\"\\n\")) || []\n      @committed_files.include?(file)\n    end\n\n    def flock(file)\n      File.open(file, \"w\") do |f|\n        begin\n          f.flock(File::LOCK_EX)\n          yield\n        ensure\n          f.flock(File::LOCK_UN)\n        end\n      end\n    end\n\n    def sh(*args)\n      ::WWTD.send(:sh, *args)\n    end\n  end\nend\n",
    "wwtd/version" => "module WWTD\n  VERSION = \"1.3.0\"\nend\n",
    "rubinjam/internal" => "module Rubinjam\n  ROOT = File.expand_path(\"../\", __FILE__) << \"/rubinjam/\"\n\n  class << self\n    def normalize_file(file)\n      return file unless file.start_with?(\"/\")\n      if file.start_with?(ROOT)\n        file.sub(ROOT, \"\")\n      else\n        file.split('/lib/').last\n      end\n    end\n\n    def file_from_nesting(mod, const)\n      if file = mod.rubinjam_autload[const]\n        return [mod, file]\n      end\n\n      nesting(mod.name)[1..-1].detect do |mod|\n        file = mod.rubinjam_autload[const]\n        break [mod, file] if file\n      end\n    end\n\n    # this does not reflect the actual Module.nesting of the caller,\n    # but it should be close enough\n    def nesting(name)\n      nesting = []\n      namespace = name.split(\"::\")\n      namespace.inject(Object) do |base, n|\n        klass = base.const_get(n)\n        nesting << klass\n        klass\n      end\n      nesting.reverse\n    end\n  end\n\n  module ModuleAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        def rubinjam_autload\n          @rubinjam_autload ||= {}\n        end\n\n        alias autoload_without_rubinjam autoload\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            rubinjam_autload[const] = normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n\n        alias const_missing_without_rubinjam const_missing\n        def const_missing(const)\n          # do not load twice / go into infitire loops\n          @rubinjam_tried_const_missing ||= {}\n          if @rubinjam_tried_const_missing[const]\n            return const_missing_without_rubinjam(const)\n          end\n          @rubinjam_tried_const_missing[const] = true\n\n          # try to find autoload in current module or nesting\n          nesting, file = Rubinjam.file_from_nesting(self, const)\n          if file\n            require file\n            nesting.const_get(const)\n          else\n            const_missing_without_rubinjam(const)\n          end\n        end\n      end\n    end\n  end\n\n  module BaseAutoloadFix\n    def self.included(base)\n      base.class_eval do\n        alias autoload_without_rubinjam autoload\n\n        def autoload(const, file)\n          normalized_file = Rubinjam.normalize_file(file)\n          if Rubinjam::LIBRARIES[normalized_file]\n            require normalized_file\n          else\n            autoload_without_rubinjam(const, file)\n          end\n        end\n      end\n    end\n  end\nend\n\nModule.send(:include, Rubinjam::ModuleAutoloadFix)\ninclude Rubinjam::BaseAutoloadFix\n\ndef require(file)\n  normalized_file = Rubinjam.normalize_file(file)\n  if code = Rubinjam::LIBRARIES[normalized_file]\n    return if code == :loaded\n    eval(code, TOPLEVEL_BINDING, \"rubinjam/\#{normalized_file}.rb\")\n    Rubinjam::LIBRARIES[normalized_file] = :loaded\n  else\n    super\n  end\nend\n"
  }
end
eval(Rubinjam::LIBRARIES.fetch("rubinjam/internal"), TOPLEVEL_BINDING, "rubinjam")
#!/usr/bin/env ruby
$LOAD_PATH << File.expand_path("../../lib", __FILE__)
require "rubygems" if RUBY_VERSION < "1.9"
require "wwtd"
exit WWTD::CLI.run(ARGV)
